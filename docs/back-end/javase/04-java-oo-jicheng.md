> 继承是一种类与类之间的关系(A is a B)
关键字： `super`,`final`,`abstract`,`抽象类`，`模板方法设计模式`

<!-- TOC START min:1 max:3 link:true asterisk:false update:true -->
- [继承的特点](#继承的特点)
- [方法重写和方法重载的区别？](#方法重写和方法重载的区别)
- [super关键字在继承中的作用？](#super关键字在继承中的作用)
- [final关键字在继承中的作用？](#final关键字在继承中的作用)
- [继承与抽象类](#继承与抽象类)
  - [抽象类的特点](#抽象类的特点)
  - [关于抽象方法](#关于抽象方法)
  - [abstract 使用 -- 模板方法设计模式](#abstract-使用----模板方法设计模式)
- [继承与接口](#继承与接口)
  - [1. 接口的基本特点](#1-接口的基本特点)
  - [2. 概念对比](#2-概念对比)
  - [3. 接口的组成](#3-接口的组成)
    - [1. 抽象方法](#1-抽象方法)
    - [2. 常量](#2-常量)
    - [3. 默认方法](#3-默认方法)
    - [4. 静态方法](#4-静态方法)
    - [5. 接口实例](#5-接口实例)
  - [多接口重名问题](#多接口重名问题)
  - [接口的继承](#接口的继承)
- [多态的概念](#多态的概念)
- [多态的特点](#多态的特点)
- [多态的应用](#多态的应用)
  - [1. 向上转型](#1-向上转型)
  - [2. 向下转型](#2-向下转型)
  - [3. instanceof 安全向下转型](#3-instanceof-安全向下转型)
  - [4. 多态用于扩展程序](#4-多态用于扩展程序)
<!-- TOC END -->


# 继承的特点
- 不同于生活中，java中子类必须继承父类的所有属性，不能选择性继承
- 子类只能继承父类的公共属性，不能继承私有属性
- java中的继承，一个只能有一个父类，不能有多个父类
- 父类不能访问子类的特有的方法和属性（即使是子类的public属性或方法）
- 一个继承体系中,查阅父类功能,创建子类对象使用(因为父类有可能不能实例化--接口和抽象类)  
- 子类中**所有构造函数**的第一行都是被隐藏的`super()`

# 方法重写和方法重载的区别？
方法重写的场景？  
父类有eat方法，子类也有eat方法，但子类不想沿用父类的方法，想要有不同的eat表现形式  
> 方法重写

```bash
1. 在有继承关系的两个类中，子类重写父类的方法
2. 方法名，方法返回值，参数列表（顺序/个数/类型）与父类完全一致
3. 子类方法访问修饰符范围 >= 父类访问修饰符范围
```

> 方法重载

```bash
1. 同一个类中
2. 方法名相同，参数列表不同（顺序/个数/类型）
3. 方法返回值，访问修饰符随意
```

无论方法重载还是方法重写，如果方法的顺序，类型相同，只是**参数名不同**，都不能构成重载或重写。  
在继承中，不仅可以重写方法，也可以在子类中定义和父类重名的属性，达到重写父类属性的效果。  

# super关键字在继承中的作用？
super是继承中的关键字，在继承中有两个作用。  

1. 子类重写父类的方法后，程序默认会调用子类重写的方法，如果，我想要调用父类的方法呢？  

```java
// 子类访问父类成员方法
super.print();
// 子类访问父类属性
super.name;
```
2. 子类对象构造过程必须调用父类构造方法，系统默认调用父类的无参构造方法，当父类有很多个构造方法时，
子类怎样自定义调用父类的构造方法呢？  

```java
public Cat(){
super(String name, int month);
}
```
在子类构造方法的第一行使用super()，让子类自定义选择父类的构造方法。

综上，super在继承中有两种用途:  
一是在子类中调用父类的成员方法和属性；  
二是在子类构造方法中帮助子类自定义选择父类构造方法  

3. super && this

```java
// 子类的无参构造方法
public Cat(){

}

// 子类的有参构造方法
public Cat(String name, int month){
this(); //调用子类的无参构造
}
```
this：当前类对象的引用  
访问当前类的成员方法/属性/构造方法  

super：父类对象的引用  
访问父类的成员方法/属性/构造方法  

子类构造方法中，this()和super()不能同时出现，因为他们都表示调用构造方法，都抢着在第一行  
同样，this和super都不能在静态方法中使用

# final关键字在继承中的作用？
> final 类中的所有方法都不能被重写,可用final有选择的修饰方法

final可修饰类/方法/变量  
1. final修饰类---该类不可被继承
2. final修饰方法--该方法不可被重写  
**final不能修饰构造方法**
3. final修饰变量
  - 成员变量：  
该成员变量只可在**构造方法代码块**或**构造代码块**中被赋值  
  - 局部变量：  
该局部变量在使用之前被赋值即可  
4. final配合static使用  
修饰一些不会变化且只加载一次的配置变量，如URL等

> 抽象类与普通类区别: 1. 多了抽象方法 2. 不能被实例化

# 继承与抽象类
Animal这个父类中有eat方法，Cat子类中也有eat方法，父类中的方法只是说明了子类都将具有**吃**这个能力，具体怎样吃，吃什么，这些都由具体子类自己去写。  

这样一来，我们就不需要调用父类中的eat方法了，更近一步，父类中的所有方法都没有调用价值(有重写价值)，再进一步，对父类的实例化也就没有意义了。这个时候，我们就可以把这个父类设置为abstract抽象类，这样父类就不能被实例化了。  

一句话总结抽象类的应用场景：  
> 某个父类只是只是知道其子类应该包含哪些方法，但无法知道这些子类如何去实现这些方法。  

这种情况下，这个父类应被设为抽象类，父类有重写价值,没有实例化价值。  

抽象的意义:  **强迫**子类重写方法.

抽象化后，如果确实要用到父类中的方法，可以通过向上转型的方式调用父类方法。  

```java
Animal animal = new Cat();
animal.eat();
```

**理解抽象**:  
类抽象成超类 -- 行为相似;  
对象抽象成类 -- 属性相似;
发现类的主要方法,  
先有抽象,通过抽象得出类,  
后通过继承表达抽象效果.

**抽象类 --- 强调一组事物的相似性,包括属性和方法的相似性.**  

## 抽象类的特点

1. 抽象方法一定要在抽象类中,抽象类中有抽象方法和非抽象方法
2. `abstract`修饰类和方法,不能修饰变量
3. 抽象类不可以 new 对象, 抽象类没有实例价值,只有重写价值
4. 抽象类中的方法如果要被使用,必须由子类重写**所有**的抽象方法后,建立子类对象调用该方法,如果子类只重写了部分抽象方法,那么**该子类还是一个抽象类**  
5. 抽象类中也可以没有抽象方法---目的在于,不让这个类实例化

## 关于抽象方法
1. 抽象方法的写法---不允许有方法体  

```java
public abstract eat();
```

2. 抽象方法与修饰符---因为抽象方法是要被子类访问重写的，所以**private/final/static**这3个修饰符不能与abstarct同时使用
[继承-抽象方法-员工经理类](https://github.com/EasterFan/JavaExercise/blob/master/objectInitInInherihance/src/com/easter/Abstract/Empolee.java)

## abstract 使用 -- 模板方法设计模式
> 确定的部分写成模板(如果不想被后人重写修改,则定义成final类), 不确定的方法部分暴露出去(可写成抽象方法),让后面的人重写完善.  


[模板方法设计模式 - 计算程序运行时间](https://github.com/EasterFan/JavaExercise/blob/master/objectInitInInherihance/src/com/easter/Abstract/Template.java)

> 当抽象类中所有方法都是抽象方法时, 我们把这个抽象类定义成**接口**

接口弥补了java单继承的遗憾，接口实现了**行为的关联**，解决了两个问题：  
1. 一个类中需兼容多种类特征的问题  
如手机类继承电脑，相机，智能手表的功能-----但java不允许多继承  

2. 多个不同类具有相同特征  
手机和相机都有拍照功能  

# 继承与接口

## 1. 接口的基本特点
1. 接口的成员(常量,方法)修饰符是固定的 - 常量:`public static final`方法:`public abstract`
2. 接口是对外暴露的规则(都是public)
3. 接口**不可以**创建对象, 因为有抽象方法需要被子类实现,子类对接口中的抽象方法**全部**重写后,**子类** 才可以实例化
4. 接口是程序的功能扩展(扩展的是体系外的功能,如果是体系内的共性功能,直接封装成内部属性)
5. **类与接口** 之间是实现关系,而且类可以继承一个类的同时实现多个接口
6. 接口与接口之间有继承关系,且**接口和接口之间可以多继承**  
7. 根据 **问题领域** 的不同,确定哪些行为可以定义为体系外的接口,**基本功能定义在类中,扩展功能定义在接口中**  
```java
// 学生类 StudentA 的主要功能是学生, 扩展功能是工作
class StudentA extends Student implements PartTimeJob{
}
```

## 2. 概念对比
1. java 为什么不支持多继承,支持多实现??  
多继承中,父类的方法名有重复,调用会出现混乱；   
多实现的方法, 只有方法名, 没有方法体,子类继承后可以任意完善方法体,所以父类方法重名也没有关系.  

2. 继承和接口实现的区别?  
  - 继承是子类**直接**拿父类的方法用,接口实现是子类将父类的方法体全部实现后,子类才能实例化调用父类的方法  
  - 类和类之间的关系是继承,接口和接口之间是继承,类和接口之间是实现.  
  - 写方法体是实现, 不写方法体是继承.  
  - 继承条件**A is a B**,接口条件**A like B**(强调行为的相似)

3. 抽象类不能被实例化,那么,抽象类有没有构造方法?  
抽象类没有实例价值, 抽象类有继承价值, 子类实例化时, 先调用父类的默认构造方法,故抽象类有构造方法.  

4. **接口类：** 没有方法体，使用该接口的类必须重写接口方法  
```java
public interface InterfaceBody {
    // 成员常量
    public static final String MY_XYZ = "xyz";

    // 成员方法
    public abstract void eat();
}
```

5. **接口的使用：** implement关键字，重写接口的 **所有方法**  
```java
public class Android implements IPhoto {

    @Override
    public void photo() {
        System.out.println("我是Android手机的拍照功能");
    }
}
```
如果你不想重写接口的所有方法，就要把自己变成抽象类，你不重写，让你的子类来重写

6. **接口测试：** 接口对象虽然由Android等实例化产生，但接口对象只能调用Android类中重写接口的方法，不能调用Android的其他方法  

```java

// 接口引用指向Android/Camara等使用接口的类
        IPhoto ip_Android = new Android();
// 接口对象只能调用接口中的方法，不能调用Android中的其他方法
        ip_Android.photo();
```

[接口的实现](https://github.com/EasterFan/JavaExercise/blob/master/interfaceProj/src/com/easter/test/_01AchievementTest.java)

## 3. 接口的组成
一个接口类由五部分组成：抽象方法，常量，默认方法，静态方法，接口实例。  
默认方法和静态方法是jdk1.8以后才支持的。  
[接口成员](https://github.com/EasterFan/JavaExercise/blob/master/interfaceProj/src/com/easter/test/_02Member.java)  

### 1. 抽象方法
接口类中默认方法都是抽象方法，自动为方法加上修饰符`public abstract`  
```java
//接口中默认的方法都是抽象方法
void network();

// 默认等价于
public abstract void network();
```
### 2. 常量
接口类中默认成员变量都是常量，自动为成员变量加上修饰符`public static final`  

```java
//接口中默认的成员变量都是常量
int temp = 1;

// 默认等价于
public static final temp = 1;
```
常量的两种调用方法：  

```java
// 1. 通过接口名调用
		IPhoto.temp
// 2. 通过接口实例调用
		IPhoto ip_Android = new Android();
		ip_Android.temp;
```
### 3. 默认方法
我们不想重写接口中的所有方法，也不想把自己变成抽象类，有没有第三种解决方法呢？   
我们把不想重写的方法定义成默认方法，就不用重写他了。  

```java
// default 默认方法 可以带方法体
		default void network(){
			System.out.print("我是接口中的默认方法");
		}
```
默认方法可以通过接口实例调用。  
或者通过接口名调用：`INet.super.network();`--测试报错  
默认方法是可以被重写的。  
### 4. 静态方法

```java
// static 静态方法 可以带方法体
		static void stop(){
			System.out.print("我是接口中的静态方法");
		}
```
静态方法只能通过接口调用。不能通过接口实例调用。  
静态方法可以被继承，不可以被重写。  

### 5. 接口实例

```java
          IPhoto ip_Android = new Android();
```
ip_Android就是一个接口实例，  
ip_Android调用的方法是接口中定义的抽象方法，  
ip_Android调用的static常量是接口中的常量  

## 多接口重名问题
java中一个类可以实现多个接口，有一个问题是，一个类实现的两个接口中有同名的 **默认方法**，或者有同名的 **常量**，此时这个类就会报错，怎样解决？  
1. 默认方法重名  
解决方法：  
在这个类中重写这个同名的默认方法，这样，用接口实例调用该方法时，会调用这个类中重写的方法。   
如果一个实现类，他的父类和接口中有重名的方法，用接口实例调用该方法时，会优先调用父类的方法。   
总结，默认同名方法调用优先级：  
> 子类同名方法 > 父类同名方法 > 接口同名方法  

2. 常量重名
当两个接口中有相同的常量时，我们在调用的时候通过`接口名+常量`的方法进行调用即可。  
当两个接口和父类中的常量同名时，父类常量不占优势了，还是需要在实现类中重新定义这个常量。  

[多接口重名问题](https://github.com/EasterFan/JavaExercise/blob/master/interfaceProj/src/com/easter/test/_03Duplication.java)  

## 接口的继承
接口之间可以实现继承关系，并且一个接口可以继承多个父接口，这一点比较特殊。  
实现这个子接口的实现类，当然就需要重写该子接口和其所有父接口的抽象方法。  

```java
interface A {
    void methodA();
}

interface B {
    void methodB();
}

// 接口的多继承
interface C extends A,B{
    void methodC();
}

// 实现这个接口,就要重写该接口的所有方法
class D implements C{

    @Override
    public void methodA() {

    }

    @Override
    public void methodB() {

    }

    @Override
    public void methodC() {

    }
}

```
[接口继承](https://github.com/EasterFan/JavaExercise/blob/master/interfaceProj/src/com/easter/test/_04Inherance.java)  


# 多态的概念
> 某一类事物有多种存在形态(人分为男人和女人 -- 称呼卓别林人或男人都可)  

多态可以分为**编译时多态**和**运行时多态**，前者表示编译器在编译时即可进行不同行为的区分，java中的多态是后者。  

```java
男人 卓别林 = new 男人();
人 卓别林 = new 男人();
```
函数的重载和重写就可以看作是 **函数的多态** -- 同一函数名对应多种方法体.  
java 中主要研究 **对象的多态**  

# 多态的特点
1. 体现  
父类或者接口的引用指向或者接收自己的子类对象。  
多态自始至终都是子类对象在做变化---向上向下转型  

2. 作用:  
多态的存在提高了程序的扩展性和后期可维护性  
简化了对象调用 -- 找到一批对象的共同特性,统一操作很多对象.  

3. 前提:  
  - 需要存在继承或者实现关系  
  - 要有覆盖操作  

4. 弊端:  
提高了扩展性,但是只能用父类引用去访问父类成员.  

5. 运行特点  
**成员函数**: -- 编译看父类,运行看子类  
  - 编译时:要查看引用变量所属的类(父类)中是否有所调用的成员。  
  - 在运行时:要查看对象所属的类(子类)中是否有所调用的成员。  
**成员变量和静态成员(static)**: -- 编译和运行都看父类  
  - 只看引用变量所属的类(父类)  

# 多态的应用

## 1. 向上转型
向上转型，小类转大类  

```java
  // 向上转型：把子类对象赋给父类引用
        Animal cat_up = new Cat();
        Animal dog_up = new Dog();
```
向上转型后的animal_cat可以调用自己重写父类的方法，可是不能再调用以前自己定义的专属的方法了。  

## 2. 向下转型
向下转型，大类转小类（需强转）  

```java
// 向下转型，大类转小类，向上转型的还原
		Cat cat_down = (Cat) cat_up;
		cat_down.eat();
		cat_down.run();
```
注意，大类转小类，是还原，这个 **大类** 本来就是从小类转成的 **大类**，由Animal类实例化的animal是不能向下转型为小类的。  

另外，向下转型，恢复成小类后，这个小类又可以调用自己原来的专属方法了。  

## 3. instanceof 安全向下转型
要向下转型，我们首先要知道要转型的这个大类，他的前身是哪一个小类，instanceof方法就是判断这个转型的大类是否属于待转型的小类。返回值为true/false。我们要做的，就是在向下转型前，加上一段判断逻辑。  

```java
if(cat_up instanceof Cat){
            Cat cat_down = (Cat) cat_up;
            cat_down.eat();
            cat_down.run();
            System.out.print("cat_up可以向下转型为Cat\n");
        }

```

[instancof安全转型](https://github.com/EasterFan/JavaExercise/blob/master/PolyProj/src/com/easter/test/PolyTest.java)  


## 4. 多态用于扩展程序
> 在主程序中写死了数据库的连接方式,会导致更改框架时(JDBC转为Hibernate),大量改代码 -- 以数据库连接的 DAO 模式为例.  

```java
// 多态的写法 -- 通过 Dao 层对两种连接方式解耦
public class PolyInJDBC {
    public static void main(String[] args) {
        // 假设使用 JDBC
        UserInfoDao ui = new GetUserInfoByJDBC();

        // 假设使用 Hibernate
        UserInfoDao ui2 = new GetUserInfoByHibernate();

    }
}
```

原来将 JDBC 连接方式写在主程序中, 换用 Hibernate 后需要大量改代码, 不能兼容其他连接方式,程序扩展性很差.  

通过引入 JDBCDAO 接口层后, **将主程序和连接方式之间进行解耦**,再加上反射,可以在不改动代码的情况下,兼容多种连接方式,从而增强程序扩展性.  
[多态用于程序扩展 -- 数据库连接的DAO设计]()
